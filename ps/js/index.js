(()=>{var e,t=/(was)? ?(not)? ?@([a-z]+) ?(.*)?/,o=/(?:was )?(?:not )?@[a-z]+ ?.*?(?:(?= and (?:was )?(?:not )?@[a-z])|$)/g,n=e=>void 0===e||"true"===e||"false"!==e&&e,r=e=>{let[,o,r,u,m]=e.match(t);return[u,n(m),"not"===r,"was"===o]},u=(e,t)=>{let n={matches:!1,active:!1,onchange:function(){},start:()=>{n.active||(n.active=!0,u.forEach((e=>e.forEach((e=>e.addListener(m))))),m())},stop:()=>{n.active=!1,u.forEach((e=>e.forEach((e=>{!e.removeListener||e.removeListener(m)}))))},destroy:()=>{n.stop(),u.length=0}},u=e.split(" or ").map((e=>(e=>e.match(o).map(r))(e).map((e=>((e,t,o)=>(e.invert=t,e.retain=o,e.matched=!1,e))(((e,t,o)=>{let n=i("monitor").find((e=>e.name===t));if(!n)throw new Error(`Conditioner: Cannot find monitor with name "@${t}". Only the "@media" monitor is always available. Custom monitors can be added with the \`addPlugin\` method using the \`monitors\` key. The name of the custom monitor should not include the "@" symbol.`);return n.create(o,e)})(t,...e),...e.splice(2)))))),m=()=>{let e=u.reduce(((e,t)=>!!e||(e=>e.reduce(((e,t)=>{if(!e)return!1;let o=t.invert?!t.matches:t.matches;return o&&(t.matched=!0),!(!t.retain||!t.matched)||o}),!0))(t)),!1);n.matches=e,n.onchange(e)};return n},m=e=>{let t=((e,t)=>{let o=c("moduleGetName",e),n=s("moduleSetName",o),r={destruct:null,mounting:!1},u={alias:o,name:n,element:e,mounted:!1,unmount:()=>{!r.destruct||!u.mounted||(l("moduleWillUnmount",u),r.destruct(),u.mounted=!1,l("moduleDidUnmount",u),u.onunmount.apply(e))},mount:()=>{if(!u.mounted&&!r.mounting)return r.mounting=!0,l("moduleWillMount",u),c("moduleImport",n).then((t=>{r.destruct=c("moduleGetDestructor",c("moduleGetConstructor",t)(...c("moduleSetConstructorArguments",n,e))),r.mounting=!1,u.mounted=!0,l("moduleDidMount",u),u.onmount.apply(e,[u])})).catch((t=>{r.mounting=!1,l("moduleDidCatch",t,u),u.onmounterror.apply(e,[t,u])})),u},destroy:function(){l("moduleWillDestroy",u),u.unmount(),l("moduleDidDestroy",u),u.ondestroy.apply(e),t()},onmounterror:function(){},onmount:function(){},onunmount:function(){},ondestroy:function(){}};return u})(e,(()=>n&&n.destroy())),o=c("moduleGetContext",e),n=o&&((e,t)=>{let o=u(e,t.element);return o.onchange=e=>e?t.mount():t.unmount(),o.start(),o})(o,t);return o?t:t.mount()},a=[],d=e=>a.push(e),i=e=>a.filter((t=>((e,t)=>e.indexOf(t)>-1)(Object.keys(t),e))).map((t=>t[e])),l=(e,...t)=>i(e).forEach((e=>e(...t))),s=(e,...t)=>i(e).reduce(((e,t)=>[t(...e)]),t).shift(),c=(e,...t)=>i(e).pop()(...t);d({moduleSelector:e=>e.querySelectorAll("[data-module]"),moduleGetContext:e=>e.dataset.context,moduleImport:e=>new Promise(((t,o)=>{if(self[e])return t(self[e]);o(`Cannot find module with name "${e}". By default Conditioner will import modules from the global scope, make sure a function named "${e}" is defined on the window object. The scope of a function defined with \`let\` or \`const\` is limited to the <script> block in which it is defined.`)})),moduleGetConstructor:e=>e,moduleGetDestructor:e=>e,moduleSetConstructorArguments:(e,t)=>[t],moduleGetName:e=>e.dataset.module,monitor:{name:"media",create:e=>self.matchMedia(e)}}),d({moduleSetName:e=>e,moduleGetConstructor:e=>e.default,moduleDidCatch:console.log,moduleImport:e=>import(`./ui/${e}.js`)}),e=document.documentElement,[...c("moduleSelector",e)].map(m),console.log("\n%cHi fellow developer!\n\nIf you're ever in need of a JavaScript image editing SDK, save yourself some time (and browser quirk headaches) and check out Pintura (%s).\n\nCheers, Rik\n\n","color: #1da1f2","https://pqina.nl/pintura")})();